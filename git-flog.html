<!DOCTYPE html> 
<html>
<meta charset="UTF-8">
<script>
function statePrototype() {
    this.commits = {};
    this.pickCommit = function(hash) {
        if (hash in this.commits) {
            return this.commits[hash];
        } else {
            var c = new commit(hash);
            this.commits[hash] = c;
            return c;
        }
    }
    this.addCommit = function(hash,desc,parents) {
        var c = this.pickCommit(hash);
        if (c.info != null) {
            throw "info already registered for " + hash;
        }
        var parent_objects = parents.map(function(p){ return this.pickCommit(p); }, this);
        c.info = new commitInfo(desc,parent_objects);
        c.sortParents();

    }
}
function scoreGT(s1, s2) {
    var l = (s1.length > s2.length) ? s2 : s1;
    for (var i = 0; i < l; ++i) {
        if (s1[i] > s2[i]) {
            return true;
        } else if (s1[i] < s2[i]) {
            return false;
        }
    }
    if (s1.length > s2.length) {
        return true;
    } else {
        return false;
    }
}
function getCommits(state,url) {
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
        if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
            addCommits(state,xmlhttp.responseText);
        }
    }
    xmlhttp.open("GET", url, true);
    xmlhttp.send();
}
function commit(hash) {
    this.sortParents = function() {
        if (this.info == null) {
            return;
        }
        var pl = this.info.parents.length;
        var handleParent = function(treeParent,p,pscore){
            if (scoreGT(pscore,p.score)) {
                p.score = pscore;
                p.treeParent = treeParent;
                p.sortParents();
            }
        }
        var nextscore = this.score.concat();
        ++nextscore[nextscore.length - 1];
        handleParent(this.treeParent,this.info.parents[0], nextscore);
        // ignore next parents so far
        // TODO: make the intermediate fake "commit"
        if (pl > 1) {
            handleParent(this,this.info.parents[1], this.score.concat([1]));
        }

        // TODO: bring this separately this
        if (this.domSelf != null) {
            document.getElementById("commits").removeChild(this.domSelf);
            this.domSelf = null;
        }
        this.domSelf = document.createElement("li");
        var a = document.createElement("a");
        a.setAttribute("href", "https://github.com/git/git/commit/" + hash);
        a.appendChild(document.createTextNode(this.info.desc));
        this.domSelf.appendChild(a);
        this.domSelf.appendChild(document.createTextNode(JSON.stringify(this.score)));
        this.domSelf.appendChild(document.createElement("br"));
        var base = (this.treeParent == null) ? document.getElementById("commits")
                    : this.treeParent.pickSublist();
        base.appendChild(this.domSelf);
    }
    this.pickSublist = function() {
        if (this.domSelf == null) {
            return null;
        }

        if (this.domSublist != null) {
            return this.domSublist;
        }
        this.domSublist = document.createElement("ul");
        this.domSelf.appendChild(this.domSublist);
        return this.domSublist;
    }

    this.hash = hash;
    this.score = [1];
    this.children = [];
    this.treeParent = null;
    this.info = null;
    this.domSelf = null;
    this.domSublist = null;
    this.domLinks = [];
}
function commitInfo(desc, parents) {
    this.desc = desc;
    this.parents = parents;
}
function addCommits(state, json) {
    var cs = JSON.parse(json);
    cs.forEach(function(c){
        var desc = c.commit.author.email + ": " + c.commit.message.split("\n")[0];
        state.addCommit(c.sha,desc,c.parents.map(function(p) { return p.sha } ));
    });
    // document.getElementById("info").textContent = json;
}
var state = new statePrototype();
getCommits(state,"https://api.github.com/repos/git/git/commits?sha=master");
</script>
<body>
<ul id="commits"></ul>
<pre id="info"></pre>
</body>
</html>
