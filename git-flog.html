<!DOCTYPE html> 
<html>
<meta charset="UTF-8">
<style>
.toggle {
    margin-right: 0.25em;
}

.block {
    display: block;
}

.inline {
    display: inline;
}

.hidden {
    display: none !important;
}

.github-avatar {
    height: 1em;
}

.greyed {
    opacity: 0.5;
}

li:target > .desc {
    background-color: orange;
}

li.linked-hovered > .desc {
    background-color: yellow;
}

.popup-background {
    position: fixed;
    z-index: 1;
    background-color: WindowText;
    opacity: 0.5;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.popup {
    position: fixed;
    top: 25%;
    left: 50%;
    z-index: 2;
    background-color: Window;
    opacity: 1;
    border: 1px solid ActiveBorder;
}

#info {
    height: 80px;
    overflow-y: scroll;
    border: 1px solid ActiveBorder;
}
</style>
<script>
function Github(repository) {
    this.activate = function() {
        // elShow("github");
        this.githubSetAuthType();
    }
    this.githubInitAuth = function() {
        switch (document.getElementById("github:authtype").value) {
        case "noauth":
            elHide("github:userinfo");
            elShow("github:anonymous");
            uiHideAuth();
            break;
        case "token":
            if (this.request != null) {
                throw "Busy";
            }
            this.startRequest(
                document.getElementById("github:username").value,
                document.getElementById("github:password").value.trim(),
                info => {
                    document.getElementById("github:userinfo:name").textContent = info["login"];
                    document.getElementById("github:userinfo:name").setAttribute("href", info["html_url"]);
                    document.getElementById("github:userinfo:avatar").setAttribute("src", info["avatar_url"]);
                    elShow("github:userinfo");
                    elHide("github:anonymous");
                    uiHideAuth();
                });
            break;
        }
    }
    this.startRequest = function(username,password,handleSuccesfulLogin) {
        if (this.request != null) {
            throw "Busy";
        }
        if (/^[a-f0-9]{40}$/.exec(password) == null) {
            alert("Please use the API token. Aren't you trying to use password?");
            this.request = null;
        } else if (username != null && username.length > 0 && password != null && password.length > 0) {
            var request = new XMLHttpRequest();
            request.open("GET", "https://api.github.com/user", true);
            request.setRequestHeader("Authorization", "Basic " + window.btoa(username + ":" + password));
            request.onreadystatechange = () => {
                if (request.readyState == 4) {
                    try {
                        if (request.status == 200) {
                            this.auth = [username, password];
                            handleSuccesfulLogin(JSON.parse(request.responseText));
                            document.getElementById("info").textContent += "login ok, user: " + info["login"] + "\n";
                        } else {
                            document.getElementById("info").textContent += "login failed, status: " + request.status + "\n";
                        }
                    } finally {
                        this.request = null;
                    }
                }
            }
            request.send();
            this.request = request;
        } else {
            this.request = null;
        }
    }
    // make refs here to have only one in heap
    var urlPrefix = "https://github.com/" + repository + "/commit/";
    var makeUrl = function(h) { return urlPrefix + h; };
    this.getMoreCommits = function(handleCommit) {
        if (this.request != null) {
            throw "Busy";
        }
        if (this.nextUrl == null) {
            throw "Nothing to get more";
        }
        this.request = new XMLHttpRequest();
        this.request.open("GET", this.nextUrl, true);
        if (this.auth != null) {
            this.request.setRequestHeader("Authorization", "Basic " + window.btoa(this.auth[0] + ":" + this.auth[1]));
        }
        var ghThis = this;
        this.request.onreadystatechange = function() {
            if (ghThis.request.readyState == 4) {
                try {
                    if (ghThis.request.status == 200) {
                        document.getElementById("info").textContent +=
                            "response: "
                            + "l_rem: " + ghThis.request.getResponseHeader("X-RateLimit-Remaining")
                            + ", l_reset: " + new Date(ghThis.request.getResponseHeader("X-RateLimit-Reset") * 1000)
                            + "\n";
                        var cs = JSON.parse(ghThis.request.responseText);
                        cs.forEach(function(c){
                            var desc = [c.commit.author.email, c.commit.message.split("\n")[0]];
                            handleCommit(c.sha,desc,c.parents.map(function(p) { return p.sha } ),makeUrl);
                        });
                        var nextUrl = null;
                        if (ghThis.request.getResponseHeader("link").split(",").some(function (link) {
                                var cs = link.split(";");
                                if (/^\s*rel="next"\s*$/.test(cs[1])) {
                                    var urlPattern = /^\s*<(https:\/\/api\.github\.com\/repositories\/[0-9]+\/commits\?sha\=[a-z0-9_\/%-]+\&per_page\=[0-9]+\&page\=[0-9]+)>$/i;
                                    nextUrl = urlPattern.exec(cs[0])[1];
                                    return true;
                                } else {
                                    return false;
                                }
                            })) {
                            ghThis.nextUrl = nextUrl;
                            elShow("continue");
                        } else {
                            ghThis.nextUrl = null;
                            elHide("continue");
                        }
                    } else {
                        document.getElementById("info").textContent += "fetch failed, status: " + ghThis.request.status + "\n";
                    }
                } finally {
                    ghThis.request = null;
                }
            }
        }
        this.request.send();
    }
    this.githubSetAuthType = function() {
        switch (document.getElementById("github:authtype").value) {
        case "noauth":
            elHide("github:auth:form");
            break;
        case "token":
            elShow("github:auth:form");
            break;
        }
    }

    this.request = null;
    this.auth = null;
    // TODO:
    // * use custom branch
    // * select first chunk at auth
    this.nextUrl = "https://api.github.com/repos/" + repository + "/commits?sha=master&per_page=100";
    this.repository = repository;
}
function githubTry(url) {
    var match = /^(https:\/\/github\.com\/|git@githu\.com:|git:\/\/github\.com\/)([^\/]+)\/([^\/]+)($|\.git|\/)/i.exec(url);
    if (match != null) {
        return new Github(match[2] + "/" + match[3]);
    } else {
        return null;
    }
}
Github.initAuth = function() {
    window.state.handler.githubInitAuth();
}
Github.setAuthType = function() {
    window.state.handler.githubSetAuthType();
}
function statePrototype(handler) {
    this.pickCommit = function(hash) {
        if (hash in this.commits) {
            return this.commits[hash];
        } else {
            var c = new commit(hash);
            this.commits[hash] = c;
            return c;
        }
    }
    this.addCommit = function(hash,desc,parents,makeUrl) {
        var c = this.pickCommit(hash);
        if (c.info != null) {
            // duplicate; nothing to do
            return;
        }
        var parent_objects = parents.map(function(p){ return this.pickCommit(p); }, this);
        if (parent_objects.length > 2) {
            console.log("octopus: " + hash);
            // octopus merge; pretend it as merged branch, each containing a merge
            var previous = null;
            var counter = 1;
            var fakeMainline = [];
            parent_objects.slice(1).forEach(p => {
                var newP = this.pickCommit(hash + ":p" + counter);
                newP.info = new commitInfo(["", "p" + counter],[null, p],h => { return "";});
                fakeMainline.push(newP);
                if (previous != null) {
                    previous.info.parents[0] = newP;
                }
                previous = newP;
                counter++;
            });
            // TODO: hide it
            previous.info.parents[0] = this.pickCommit("none");
            parent_objects = [parent_objects[0], fakeMainline[0]];
        }
        c.info = new commitInfo(desc,parent_objects,makeUrl);
        c.sortParents();

    }
    this.getMoreCommits = function() {
        var sThis = this;
        this.handler.getMoreCommits(function(h,d,p,m) { sThis.addCommit(h,d,p,m) });
    }

    this.commits = {};
    this.handler = handler;
}
function scoreGT(s1, s2) {
    var l = (s1.length > s2.length) ? s2.length : s1.length;
    for (var i = 0; i < l; ++i) {
        if (s1[i] > s2[i]) {
            return true;
        } else if (s1[i] < s2[i]) {
            return false;
        }
    }
    if (s1.length > s2.length) {
        return true;
    } else {
        return false;
    }
}
function commit(hash, makeUrl) {
    this.sortParents = function() {
        if (this.info == null) {
            return;
        }
        this.render();
        var pl = this.info.parents.length;
        var handleParent = function(treeParent,p,pscore){
            p.renderLink(treeParent);
            if (scoreGT(pscore,p.score)) {
                p.score = pscore;
                p.treeParent = treeParent;
                p.sortParents();
            }
        }
        if (pl > 0) {
            var nextscore = this.score.concat();
            ++nextscore[nextscore.length - 1];
            handleParent(this.treeParent,this.info.parents[0], nextscore);

            // ignore next parents so far
            // TODO: make the intermediate fake "commit"
            if (pl > 1) {
                handleParent(this,this.info.parents[1], this.score.concat([1]));
            }
        }
    }
    this.render = function() {
        if (this.domSelf != null) {
            document.getElementById("commits").removeChild(this.domSelf);
            this.domSelf = null;
        }
        this.domSelf = document.createElement("li");
        this.domSelf.id = "li:" + this.hash;
        this.domSelf.innerHTML = '<a class="desc"></a><span></span>';
        this.domSelf.childNodes[0].setAttribute("href", this.info.makeUrl(this.hash));
        this.domSelf.childNodes[0].textContent = this.info.desc[0] + ": " + this.info.desc[1];
        this.domSelf.childNodes[1].textContent = JSON.stringify(this.score);
        var base = (this.treeParent == null) ? document.getElementById("commits")
                    : this.treeParent.pickSublist();
        var prevDomLink = base.lastChild;
        if (prevDomLink != null) {
            var prevLinkText = prevDomLink.children[0].textContent;
            if (prevLinkText == "-> " + this.hash) {
                base.removeChild(prevDomLink);
                this.domLinks = this.domLinks.filter(link => { return link != prevDomLink; });
            }
        }
        base.appendChild(this.domSelf);
        this.enableLinks();
    }
    this.renderLink = function(treeParent) {
        var dom = document.createElement("li");
        dom.innerHTML = "<a>-> " + this.hash + "</a>";
        var base = (treeParent == null) ? document.getElementById("commits")
                    : treeParent.pickSublist();
        if (base != null) {
            base.appendChild(dom);
        }
        this.domLinks.push(dom);
    }
    this.enableLinks = function() {
        this.domLinks.forEach(link => {
            link.children[0].setAttribute("href", "#li:" + this.hash);
            link.children[0].textContent = "-> ";
            var subject = document.createElement("span");
            subject.textContent = this.info.desc[1];
            subject.classList.add("greyed");
            link.appendChild(subject);
            link.addEventListener("mouseover", () => this.onHoveredOn());
            link.addEventListener("mouseout", () => this.onHoveredOff());
        });
    }
    this.onHoveredOn = function() {
        if (this.domSelf != null) {
            this.domSelf.classList.add("linked-hovered");
        }
    }
    this.onHoveredOff = function() {
        if (this.domSelf != null) {
            this.domSelf.classList.remove("linked-hovered");
        }
    }
    this.pickSublist = function() {
        if (this.domSelf == null) {
            return null;
        }

        if (this.domSublist != null) {
            return this.domSublist;
        }
        this.domToggle = document.createElement("a");
        this.domToggle.textContent = "[>]";
        // this.domToggle.setAttribute("id", "tg:" + this.hash);
        this.domToggle.setAttribute("href", "javascript:state.commits[\"" + this.hash + "\"].toggle();");
        this.domToggle.setAttribute("class", "toggle");
        this.domSelf.insertBefore(this.domToggle, this.domSelf.childNodes[0]);
        this.domSublist = document.createElement("ul");
        // this.domSublist.setAttribute("id", "ul:" + this.hash);
        this.domSelf.appendChild(this.domSublist);
        this.domSublist.setAttribute("hidden", "")
        return this.domSublist;
    }
    this.toggle = function() {
        if (this.domSublist == null) {
            throw "sublist not defined: " + this.hash;
        }
        if (this.domSublist.hasAttribute("hidden")) {
            this.domSublist.removeAttribute("hidden");
            this.domToggle.textContent = "[v]";
        } else {
            this.domSublist.setAttribute("hidden", "");
            this.domToggle.textContent = "[>]";
        }
    }

    this.hash = hash;
    this.score = [1];
    this.children = [];

    // if null - to top mainline
    // if commit `c` - to the mainline merged to `c`
    this.treeParent = null;
    this.info = null;
    // the topmost element
    this.domSelf = null;
    // if the commit is a merge, the list which contains the merged mainline
    this.domSublist = null;
    // if the commit is a merge, the toggle button
    this.domToggle = null;
    this.domLinks = [];
}
function commitInfo(desc, parents,makeUrl) {
    this.desc = desc;
    this.parents = parents;
    this.makeUrl = makeUrl;
}
var state = null;
function uiStart() {
    var url = document.getElementById("start:url").value;
    if (startWithUrl(url)) {
        window.location.search = "?url=" + encodeURIComponent(url);
    }
}
function startWithUrl(url) {
    var handler = null;
    if ([githubTry].some(function (h) { handler = h(url); return (handler != null) })) {
        elHide("start");
        handler.activate();
        window.state = new statePrototype(handler);
        elShow("repo");
        document.getElementById("repo:path").textContent = url;
        return true;
    }
    return false;
}
function uiContinue() {
    if (window.state == null) {
        throw "uiContinue(): Unexpected: state must be defined";
    }
    window.state.getMoreCommits();
}
function elShow(elName) {
    document.getElementById(elName).classList.remove("hidden");
}
function elHide(elName) {
    document.getElementById(elName).classList.add("hidden");
}
function expandFocused() {
    var commit = window.state.commits[location.hash.replace("#li:","")];
    var treeParent = commit.treeParent;
    var wasHidden = false;
    while (treeParent != null) {
        if (treeParent.domSublist.hasAttribute("hidden")) {
            treeParent.domSublist.removeAttribute("hidden");
            treeParent.domToggle.textContent = "[v]";
            wasHidden = true;
        }
        treeParent = treeParent.treeParent;
    }
    if (wasHidden) {
        document.getElementById(location.hash.replace("#", "")).scrollIntoView();
    }
}
function uiPopupAuth()
{
    elShow("github:login:popup:back");
    elShow("github:login:popup");
}
function uiHideAuth()
{
    elHide("github:login:popup:back");
    elHide("github:login:popup");
}
function uiInit()
{
    window.onhashchange = expandFocused;
    window.location.hash = "";
    var m = /(?:\?|&)url\=([^&]*)(?:$|&)/.exec(window.location.search);
    if (m != null) {
        var url = m[1];
        startWithUrl(decodeURIComponent(url));
    }
}
</script>
<body onload="uiInit()">
<form id="start" class="block" action="javascript:uiStart();">
 <input id="start:url" type="text" name="url">
 <input type="submit" value="Browse This Repository">
</form>
<div id="repo" class="inline hidden">
 Browsing:
 <span id="repo:path"></span>
</div>
as
 <div id="github:anonymous" class="inline">Anonymous</div>
 <div id="github:userinfo" class="inline hidden">
  <img id="github:userinfo:avatar" src="" class="github-avatar"> <a id="github:userinfo:name" href="" target="_blank"></a>
 </div>
 <a href="javascript:uiPopupAuth();">Change</a>
</div>
<ul id="commits"></ul>
<form id="continue" action="javascript:uiContinue();">
 <input type="submit" value="Continue"> <!-- TODO: properly show it -->
</form>
<pre id="info"></pre>
<div id="github:login:popup:back" class="popup-background hidden" onClick="javascript:uiHideAuth();">
</div>
 <div id="github:login:popup" class="popup hidden">
  Left: <span id="limit:remaining">0</span>, reset at <span id="limit:reset"></span>.
  <br>
  Change login to
  <form id="github:login" action="javascript:Github.initAuth();" class="block">
   <select id="github:authtype" onChange="Github.setAuthType();">
    <option value="noauth" selected>Anonymous</option>
    <option value="token">Token login</option>
   </select>
   <span id="github:auth:form" class="hidden">
    User: <input id="github:username" type="text" name="username">
    Token: <input id="github:password" type="password" name="token">
    (<a href="https://github.com/settings/tokens/new?scopes=&description=git-flog%20token" target="_blank">Get token</a>)
   </span>
   <input type="submit" value="Change">
  </form>
 </div>
</body>
</html>
